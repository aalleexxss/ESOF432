import React from 'react';
import { useThemeUI, jsx, Context, merge } from '@theme-ui/core';
import { __internalGetUseRootStyles, css, get } from '@theme-ui/css';
import { ThemeContext, Global } from '@emotion/react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const stripKeyDefault = key => key.replace('-__default', '');

const toVarName = key => `--theme-ui-${stripKeyDefault(key)}`;

const toVarValue = (key, value) => `var(${toVarName(key)}, ${value})`;

const join = (...args) => args.filter(Boolean).join('-');

const numberScales = {
  fontWeights: true,
  lineHeights: true
};
const reservedKeys = {
  useCustomProperties: true,
  initialColorModeName: true,
  printColorModeName: true,
  initialColorMode: true,
  useLocalStorage: true
};

const toPixel = (key, value) => {
  if (typeof value !== 'number') return value;
  if (numberScales[key]) return value;
  return value + 'px';
}; // convert theme values to custom properties


const toCustomProperties = (obj, parent, themeKey) => {
  const next = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    const value = obj[key];
    const name = join(parent, key);

    if (value && typeof value === 'object') {
      next[key] = toCustomProperties(value, name, key);
      continue;
    }

    if (reservedKeys[key]) {
      next[key] = value;
      continue;
    }

    const val = toPixel(themeKey || key, value);
    next[key] = toVarValue(name, val);
  }

  return next;
};
const objectToVars = (parent, obj) => {
  let vars = {};

  for (let key in obj) {
    if (key === 'modes') continue;
    const name = join(parent, key);
    const value = obj[key];

    if (value && typeof value === 'object') {
      vars = _extends({}, vars, objectToVars(name, value));
    } else {
      vars[toVarName(name)] = value;
    }
  }

  return vars;
}; // create root styles for color modes

const createColorStyles = (theme = {}) => {
  const use = __internalGetUseRootStyles(theme);

  if (!theme.colors || use.rootStyles === false) return {};

  if (theme.useCustomProperties === false || !theme.colors.modes) {
    return css({
      [use.scope]: {
        color: 'text',
        bg: 'background'
      }
    })(theme);
  }

  const {
    colors,
    initialColorModeName,
    printColorModeName
  } = theme;
  const modes = colors.modes || {};
  const styles = objectToVars('colors', colors);
  Object.keys(modes).forEach(mode => {
    const key = `&.theme-ui-${mode}`;
    styles[key] = objectToVars('colors', modes[mode]);
  });

  if (printColorModeName) {
    const mode = printColorModeName === 'initial' || printColorModeName === initialColorModeName ? colors : modes[printColorModeName];
    styles['@media print'] = objectToVars('colors', mode);
  }

  const colorToVarValue = color => toVarValue(`colors-${color}`, get(theme, `colors.${color}`));

  return css({
    [use.scope]: _extends({}, styles, {
      color: colorToVarValue('text'),
      bg: colorToVarValue('background')
    })
  })(theme);
};

const STORAGE_KEY = 'theme-ui-color-mode';
const storage = {
  get: init => {
    try {
      return window.localStorage.getItem(STORAGE_KEY) || init;
    } catch (e) {
      console.warn('localStorage is disabled and color mode might not work as expected.', 'Please check your Site Settings.', e);
    }
  },
  set: value => {
    try {
      window.localStorage.setItem(STORAGE_KEY, value);
    } catch (e) {
      console.warn('localStorage is disabled and color mode might not work as expected.', 'Please check your Site Settings.', e);
    }
  }
};

const getPreferredColorScheme = () => {
  if (typeof window !== 'undefined' && window.matchMedia) {
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }

    if (window.matchMedia('(prefers-color-scheme: light)').matches) {
      return 'light';
    }
  }

  return null;
};

const useColorModeState = (theme = {}) => {
  const [mode, setMode] = React.useState(() => {
    const preferredMode = theme.useColorSchemeMediaQuery !== false && getPreferredColorScheme();
    return preferredMode || theme.initialColorModeName || 'default';
  }); // read color mode from local storage

  React.useEffect(() => {
    const stored = theme.useLocalStorage !== false && storage.get();
    document.documentElement.classList.remove('theme-ui-' + stored);
    document.body.classList.remove('theme-ui-' + stored);

    if (stored && stored !== mode) {
      setMode(stored);
    }
  }, []);
  React.useEffect(() => {
    if (mode && theme.useLocalStorage !== false) {
      storage.set(mode);
    }
  }, [mode]);

  if (process.env.NODE_ENV !== 'production') {
    if (theme.colors && theme.colors.modes && theme.initialColorModeName && Object.keys(theme.colors.modes).indexOf(theme.initialColorModeName) > -1) {
      console.warn('The `initialColorModeName` value should be a unique name' + ' and cannot reference a key in `theme.colors.modes`.');
    }
  }

  return [mode, setMode];
};

function useColorMode() {
  const {
    colorMode,
    setColorMode
  } = useThemeUI();

  if (typeof setColorMode !== 'function') {
    throw new Error(`[useColorMode] requires the ColorModeProvider component`);
  } // We're allowing the user to specify a narrower type for its color mode name.


  return [colorMode, setColorMode];
}

const applyColorMode = (theme, mode) => {
  if (!mode) return theme;
  const modes = get(theme, 'colors.modes', {});
  return merge.all({}, theme, {
    colors: get(modes, mode, {})
  });
};

const BodyStyles = ({
  theme
}) => jsx(Global, {
  styles: () => {
    return createColorStyles(theme);
  }
});

const ColorModeProvider = ({
  children
}) => {
  const outer = useThemeUI();
  const [colorMode, setColorMode] = useColorModeState(outer.theme);
  const theme = applyColorMode(outer.theme || {}, colorMode);

  const emotionTheme = _extends({}, theme);

  if (theme.useCustomProperties !== false) {
    emotionTheme.colors = toCustomProperties(emotionTheme.colors, 'colors');
  }

  const context = _extends({}, outer, {
    theme,
    colorMode,
    setColorMode
  });

  return jsx(ThemeContext.Provider, {
    value: emotionTheme
  }, jsx(Context.Provider, {
    value: context
  }, jsx(BodyStyles, {
    key: 'color-mode',
    theme
  }), children));
};
const noflash = `(function() { try {
  var mode = localStorage.getItem('theme-ui-color-mode');
  if (!mode) return
  document.documentElement.classList.add('theme-ui-' + mode);
  document.body.classList.add('theme-ui-' + mode);
} catch (e) {} })();`;
const InitializeColorMode = () => jsx('script', {
  key: 'theme-ui-no-flash',
  dangerouslySetInnerHTML: {
    __html: noflash
  }
});

export { ColorModeProvider, InitializeColorMode, useColorMode };
//# sourceMappingURL=index.modern.js.map
